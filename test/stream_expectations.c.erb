#include "stream_expectations.h"

/* Ordered from 0 to queue_size - 1 */
struct test_assertion assertions_queue[MAX_QUEUE_ITEMS];
size_t queue_size = 0;
size_t current_expectation = 0;
decoder_t * decoder;


void set_decoder(decoder_t * dec)
{
	decoder = dec;
}

/* Callbacks */
struct test_assertion current()
{
	return assertions_queue[current_expectation];
}

/* Assertions builders */
<% %w(u neg).each do |type| %>
	<% [8, 16, 32, 64].each do |width| %>
		void assert_<%= type %>int<%= width %>_eq(uint<%= width %>_t actual)
		{
			assertions_queue[queue_size++] = (struct test_assertion) { <%= type.upcase %>INT<%= width %>_EQ, (union test_expectation_data) { .int<%= width %> = actual } };
		}

		enum cbor_callback_result <%= type %>int<%= width %>_callback(uint<%= width %>_t actual)
		{
			assert_true(current().expectation == <%= type.upcase %>INT<%= width %>_EQ);
			assert_true(current().data.int<%= width %> == actual);
			current_expectation++;
			return CBOR_CALLBACK_OK;
		}
	<% end %>
<% end %>

const struct cbor_callbacks asserting_callbacks = {
	<% %w(u neg).each do |type| %>
		<% [8, 16, 32, 64].each do |width| %>
			.<%= type %>int<%= width %> = &<%= type %>int<%= width %>_callback,
		<% end %>
	<% end %>
	.indef_break = NULL
};

struct cbor_decoder_result decode(cbor_data source, size_t source_size)
{
	struct cbor_decoder_result result = decoder(source, source_size, &asserting_callbacks);
	/* Check remaining assertions */
	assert_true(current_expectation == queue_size);
	/* Clean up */
	current_expectation = queue_size = 0;
	return result;
}


