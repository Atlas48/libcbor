#include "stream_expectations.h"

/* Ordered from 0 to queue_size - 1 */
struct test_assertion assertions_queue[MAX_QUEUE_ITEMS];
size_t queue_size = 0;
size_t current_expectation = 0;
decoder_t * decoder;


void set_decoder(decoder_t * dec)
{
	decoder = dec;
}

/* Callbacks */
struct test_assertion current()
{
	return assertions_queue[current_expectation];
}

/* Assertions builders and matcher callbacks */
// TODO parametrize this with with width instead?
<% %w(u neg).each do |type| %>
	<% [8, 16, 32, 64].each do |width| %>
		void assert_<%= type %>int<%= width %>_eq(uint<%= width %>_t actual)
		{
			assertions_queue[queue_size++] = (struct test_assertion) { <%= type.upcase %>INT<%= width %>_EQ, (union test_expectation_data) { .int<%= width %> = actual } };
		}

		enum cbor_callback_result <%= type %>int<%= width %>_callback(uint<%= width %>_t actual)
		{
			assert_true(current().expectation == <%= type.upcase %>INT<%= width %>_EQ);
			assert_true(current().data.int<%= width %> == actual);
			current_expectation++;
			return CBOR_CALLBACK_OK;
		}
	<% end %>
<% end %>

void assert_bstring_mem_eq(cbor_data address, size_t length)
{
	assertions_queue[queue_size++] = (struct test_assertion) { BSTRING_MEM_EQ, (union test_expectation_data) { .string = { address, length } } };
}

enum cbor_callback_result byte_string_callback(cbor_data address, size_t length)
{
	assert_true(current().expectation == BSTRING_MEM_EQ);
	assert_true(current().data.string.address == address);
	assert_true(current().data.string.length == length);
	current_expectation++;
	return CBOR_CALLBACK_OK;
}

void assert_bstring_indef_start()
{
	assertions_queue[queue_size++] = (struct test_assertion) { .expectation = BSTRING_INDEF_START };
}

enum cbor_callback_result byte_string_start_callback()
{
	assert_true(current().expectation == BSTRING_INDEF_START);
	current_expectation++;
	return CBOR_CALLBACK_OK;
}

void assert_indef_break()
{
	assertions_queue[queue_size++] = (struct test_assertion) { .expectation = INDEF_BREAK };
}

enum cbor_callback_result indef_break_callback()
{
	assert_true(current().expectation == INDEF_BREAK);
	current_expectation++;
	return CBOR_CALLBACK_OK;
}

<% %w(array map).each do |type| %>
	void assert_<%= type %>_start(size_t length)
	{
		assertions_queue[queue_size++] = (struct test_assertion) { <%= type.upcase %>_START, { .length = length } };
	}


	enum cbor_callback_result <%= type %>_start_callback(size_t length)
	{
		assert_true(current().expectation == <%= type.upcase %>_START);
		assert_true(current().data.length == length);
		current_expectation++;
		return CBOR_CALLBACK_OK;
	}

	void assert_indef_<%= type %>_start()
	{
		assertions_queue[queue_size++] = (struct test_assertion) { .expectation = <%= type.upcase %>_INDEF_START };
	}

	enum cbor_callback_result indef_<%= type %>_start_callback()
	{
		assert_true(current().expectation == <%= type.upcase %>_INDEF_START);
		current_expectation++;
		return CBOR_CALLBACK_OK;
	}
<% end %>

<% [['half', 2, 'double'], ['float', 4], ['double', 8]].each do |decimal| %>
	void assert_<%= decimal[0] %>(<%= decimal[2] || decimal[0] %> value)
	{
		assertions_queue[queue_size++] = (struct test_assertion) { <%= decimal[0].upcase %>_EQ, { .float<%= decimal[1] %> = value } };
	}

	enum cbor_callback_result <%= decimal[0] %>_callback(<%= decimal[2] || decimal[0] %> actual)
	{
		assert_true(current().expectation == <%= decimal[0].upcase %>_EQ);
		assert_true(current().data.float<%= decimal[1] %> == actual);
		current_expectation++;
		return CBOR_CALLBACK_OK;
	}
<% end %>

const struct cbor_callbacks asserting_callbacks = {
	<% %w(u neg).each do |type| %>
		<% [8, 16, 32, 64].each do |width| %>
			.<%= type %>int<%= width %> = &<%= type %>int<%= width %>_callback,
		<% end %>
	<% end %>

	.byte_string = &byte_string_callback,
	.byte_string_start = &byte_string_start_callback,

	<% %w(array map).each do |type| %>
		.<%= type %>_start = &<%= type %>_start_callback,
		.indef_<%= type %>_start = &indef_<%= type %>_start_callback,
	<% end %>

	<% [['half', 2], ['float', 4], ['double', 8]].each do |decimal| %>
		.float<%= decimal[1] %> = &<%= decimal[0] %>_callback,
	<% end %>

	.indef_break = &indef_break_callback
};

struct cbor_decoder_result decode(cbor_data source, size_t source_size)
{
	struct cbor_decoder_result result = decoder(source, source_size, &asserting_callbacks);
	/* Check remaining assertions */

	assert_true(current_expectation == queue_size);
	/* Clean up */
	current_expectation = queue_size = 0;
	return result;
}


